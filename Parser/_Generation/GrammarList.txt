%token identifier keyword_underscore keyword_var keyword_shader keyword_interface keyword_bool keyword_int keyword_nat keyword_float keyword_void keyword_goto lparen rparen oper_union oper_assign constant_number literalized_number constant_float constant_text oper_plus oper_minus oper_star oper_slash oper_percent oper_left_left oper_right_right oper_accent oper_stand oper_ampersand oper_equal oper_not_equal oper_less_than oper_less_than_equal oper_greater_than oper_greater_than_equal fakelparen lbrack rbrack oper_dot lscope rscope statement_end oper_colon keyword_seg oper_plus_assign oper_minus_assign oper_star_assign oper_slash_assign oper_percent_assign oper_left_left_assign oper_right_right_assign oper_accent_assign oper_stand_assign oper_ampersand_assign keyword_if keyword_else keyword_while keyword_graphic
%start start
%%
start:
		module_space;

module_space:
		module_item module_space
	|	module_item;

module_item:
		interface
	|	shader
	|	module;

interface:
		declare defargs code;

declare:
		type identifier
	|	type keyword_underscore
	|	keyword_var identifier
	|	keyword_var keyword_underscore;

type:
		keyword_shader
	|	keyword_interface
	|	keyword_bool
	|	keyword_int
	|	keyword_nat
	|	keyword_float
	|	keyword_void
	|	keyword_goto
	|	location;

defargs:
		lparen defunion rparen
	|	lparen rparen;

defunion:
		declare oper_union defunion
	|	declare
	|	defassignunion;

defassignunion:
		declare oper_assign item oper_union defassignunion
	|	declare oper_assign item;

lval:
		call_item
	|	array_access
	|	array
	|	location;

// NOTE: Item is special, in the sence that an Operator Precedence Parser will
//	be used to apply expressions using the "nterm_expression" nonterminal, in
//	C++ itself. This is applied automatically, and therfore, do NOT change
//	another rule's name to item.
item:
		expression;

rval:
		single_arg
	|	fakecall
	|	constant_number
	|	literalized_number
	|	constant_float
	|	constant_text
	|	oper_minus item
	|	oper_plus item
	|	item oper_plus_plus
	|	item oper_minus_minus;


single_arg:
		lparen paren_oper rparen
		lparen item rparen;

paren_oper:
		any_oper union;

any_oper:
		oper_plus
	|	oper_minus
	|	oper_star
	|	oper_slash
	|	oper_percent
	|	oper_left_left
	|	oper_right_right
	|	oper_accent
	|	oper_stand
	|	oper_ampersand
	|	oper_equal
	|	oper_not_equal
	|	oper_less_than
	|	oper_less_than_equal
	|	oper_greater_than
	|	oper_greater_than_equal;

fakecall:
	// NOTE: fakelparen is a workaround for the following conflict.
	//	location "%" "(" item ")" for modulating location against item
	//	location "%" "(" item ")" for fake calling location
	// The workaround consists of merging "%" and "(" into one single token,
	//	so we would have the two following non-conflicting statements.
	//	location "%" "(" item ")" for modulating location against item
	//	location "%(" item ")" for fake calling location
		item fakelparen fakecall_union rparen
	|	item fakelparen rparen;

fakecall_union:
		item oper_union fakecall_union
	|	item
	|	keyword_underscore oper_union fakecall_union
	|	keyword_underscore;

call_item:
		item lparen union rparen
	|	item lparen paren_oper rparen
	|	item lparen rparen;

union:
		item oper_union union
	|	item;

array_access:
		item lbrack item rbrack;

array:
		lbrack union rbrack
	|	lbrack rbrack;

location:
		identifier oper_dot location
	|	identifier;

code:
		lscope stmtunion rscope
	|	lscope rscope;

stmtunion:
		stmt statement_end stmtunion
	|	stmt;

stmt:
		if
	|	if_else
	|	simple_stmt
	|	statement_end;

simple_stmt:
		goto_stmt
	|	seg_stmt
	|	vardef
	|	assign
	|	item;

goto_stmt:
		keyword_goto oper_colon identifier;

seg_stmt:
		keyword_seg oper_colon identifier;

vardef:
		declare_union
	|	declare_union oper_assign item;

declare_union:
		type sid_union
	|	keyword_var sid_union;

sid_union:
		identifier sid_union
	|	identifier
	|	keyword_underscore sid_union
	|	keyword_underscore;

assign:
		item assign_oper item;

assign_oper:
		oper_assign
	|	oper_plus_assign
	|	oper_minus_assign
	|	oper_star_assign
	|	oper_slash_assign
	|	oper_percent_assign
	|	oper_left_left_assign
	|	oper_right_right_assign
	|	oper_accent_assign
	|	oper_stand_assign
	|	oper_ampersand_assign;

if:
		keyword_if		single_arg if
	|	keyword_if		single_arg simple_stmt statement_end
	|	keyword_if		single_arg code

	|	keyword_if		single_arg if_else						keyword_else if
	|	keyword_if		single_arg simple_stmt statement_end	keyword_else if
	|	keyword_if		single_arg code							keyword_else if

	|	keyword_if		single_arg if_else						keyword_else simple_stmt statement_end
	|	keyword_if		single_arg simple_stmt statement_end	keyword_else simple_stmt statement_end
	|	keyword_if		single_arg code							keyword_else simple_stmt statement_end

	|	keyword_if		single_arg if_else						keyword_else code
	|	keyword_if		single_arg simple_stmt statement_end	keyword_else code
	|	keyword_if		single_arg code							keyword_else code

	|	keyword_while	single_arg if
	|	keyword_while	single_arg simple_stmt
	|	keyword_while	single_arg code;

if_else:
		keyword_if		single_arg if_else						keyword_else if_else
	|	keyword_if		single_arg simple_stmt					keyword_else if_else
	|	keyword_if		single_arg code							keyword_else if_else

	|	keyword_while	single_arg if_else;

shader:
		keyword_graphic declare defargs code;

module:
		identifier lbrack module_space rbrack
	|	identifier lbrack rbrack;



// Example grammar
//	start: expr start | expr
//
//	expr: B | expr A

// Example lex
//	B A A B

// Example of Bottom-Up Shift-reduce parsing
//		Stack       Lookahead       Future          Action
//	B           | A             | AB        |   expr: B
//	expr        | A             | AB        |   Shift
//	expr A      | A             | B         |   expr: expr A
//	expr        | A             | B         |   Shift
//	expr A      | B             | ...       |   expr: expr A
//	expr        | B             | ...       |   Shift
//	expr B      | ...           | ...       |   expr: B
//	expr expr   | ...           | ...       |   start: expr
//	expr start  | ...           | ...       |   start: expr start
//	start       | ...           | ...       |   Accept

// Example of Top-Down infinity lookahead parsing
//		Stack                           Action
//	start                       (   start: expr start
//	expr start                  )   expr: expr A
//	expr A start                (   expr: expr A
//	expr A A start              )   expr: B
//	B A A start                 (   Pop
//	A A start                   )   Pop
//	A start                     (   Pop
//	start                       )   start: expr
//	expr                        (   expr: B
//	B                           )   Pop
//	...                         (   Accept
//	Note that since this grammar contains Left-recursive rules, LL parsers can
//	piss their pants. That's why the LL parser is said to have infinity tokens
//	of lookahead, which is ofc, impossible.
